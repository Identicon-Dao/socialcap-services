import { bigIntToBytes, bytesToBigInt } from '../bigint-helpers.js';
import { Infinity } from './curve.js';
export { fieldToRust, fieldFromRust, fieldsToRustFlat, fieldsFromRustFlat, maybeFieldToRust, affineToRust, affineFromRust, };
// TODO: Hardcoding this is a little brittle
// TODO read from field
const fieldSizeBytes = 32;
// field, field vectors
// TODO make more performant
function fieldToRust([, x]) {
    return Uint8Array.from(bigIntToBytes(x, fieldSizeBytes));
}
function fieldFromRust(x) {
    return [0, bytesToBigInt(x)];
}
// TODO avoid intermediate Uint8Arrays
function fieldsToRustFlat([, ...fields]) {
    let n = fields.length;
    let flatBytes = new Uint8Array(n * fieldSizeBytes);
    for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {
        let fieldBytes = fieldToRust(fields[i]);
        flatBytes.set(fieldBytes, offset);
    }
    return flatBytes;
}
function fieldsFromRustFlat(fieldBytes) {
    let n = fieldBytes.length / fieldSizeBytes;
    if (!Number.isInteger(n)) {
        throw Error('fieldsFromRustFlat: invalid bytes');
    }
    let fields = Array(n);
    for (let i = 0, offset = 0; i < n; i++, offset += fieldSizeBytes) {
        let fieldView = new Uint8Array(fieldBytes.buffer, offset, fieldSizeBytes);
        fields[i] = fieldFromRust(fieldView);
    }
    return [0, ...fields];
}
function maybeFieldToRust(x) {
    return x && fieldToRust(x);
}
function affineFromRust(pt) {
    if (pt.infinity) {
        pt.free();
        return 0;
    }
    else {
        let x = fieldFromRust(pt.x);
        let y = fieldFromRust(pt.y);
        pt.free();
        return [0, [0, x, y]];
    }
}
function affineToRust(pt, makeAffine) {
    let res = makeAffine();
    if (pt === Infinity) {
        res.infinity = true;
    }
    else {
        let [, [, x, y]] = pt;
        res.x = fieldToRust(x);
        res.y = fieldToRust(y);
    }
    return res;
}
//# sourceMappingURL=conversion-base.js.map