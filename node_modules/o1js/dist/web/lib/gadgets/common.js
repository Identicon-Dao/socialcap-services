import { Provable } from '../provable.js';
import { Field, FieldConst } from '../field.js';
import { TupleN } from '../util/types.js';
import { Snarky } from '../../snarky.js';
import { MlArray } from '../ml/base.js';
const MAX_BITS = 64;
export { MAX_BITS, exists, assert, bitSlice, witnessSlice, witnessNextValue, divideWithRemainder, };
function exists(n, compute) {
    let varsMl = Snarky.exists(n, () => MlArray.mapTo(compute(), FieldConst.fromBigint));
    let vars = MlArray.mapFrom(varsMl, (v) => new Field(v));
    return TupleN.fromArray(n, vars);
}
function assert(stmt, message) {
    if (!stmt) {
        throw Error(message ?? 'Assertion failed');
    }
}
function bitSlice(x, start, length) {
    return (x >> BigInt(start)) & ((1n << BigInt(length)) - 1n);
}
function witnessSlice(f, start, length) {
    if (length <= 0)
        throw Error('Length must be a positive number');
    return Provable.witness(Field, () => {
        let n = f.toBigInt();
        return new Field((n >> BigInt(start)) & ((1n << BigInt(length)) - 1n));
    });
}
function witnessNextValue(current) {
    return Provable.witness(Field, () => new Field(current.toBigInt() >> 16n));
}
function divideWithRemainder(numerator, denominator) {
    const quotient = numerator / denominator;
    const remainder = numerator - denominator * quotient;
    return { quotient, remainder };
}
//# sourceMappingURL=common.js.map