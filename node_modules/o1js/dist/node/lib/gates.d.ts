import { type Field } from './field.js';
import { TupleN } from './util/types.js';
export { rangeCheck0, rangeCheck1, xor, zero, rotate, generic };
declare function rangeCheck0(x: Field, xLimbs12: TupleN<Field, 6>, xLimbs2: TupleN<Field, 8>, isCompact: boolean): void;
/**
 * the rangeCheck1 gate is used in combination with the rangeCheck0,
 * for doing a 3x88-bit range check
 */
declare function rangeCheck1(v2: Field, v12: Field, vCurr: TupleN<Field, 13>, vNext: TupleN<Field, 15>): void;
declare function rotate(field: Field, rotated: Field, excess: Field, limbs: [Field, Field, Field, Field], crumbs: [Field, Field, Field, Field, Field, Field, Field, Field], two_to_rot: bigint): void;
/**
 * Asserts that 16 bit limbs of input two elements are the correct XOR output
 */
declare function xor(input1: Field, input2: Field, outputXor: Field, in1_0: Field, in1_1: Field, in1_2: Field, in1_3: Field, in2_0: Field, in2_1: Field, in2_2: Field, in2_3: Field, out0: Field, out1: Field, out2: Field, out3: Field): void;
/**
 * [Generic gate](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=foreignfield#double-generic-gate)
 * The vanilla PLONK gate that allows us to do operations like:
 * * addition of two registers (into an output register)
 * * multiplication of two registers
 * * equality of a register with a constant
 *
 * More generally, the generic gate controls the coefficients (denoted `c_`) in the equation:
 *
 * `c_l*l + c_r*r + c_o*o + c_m*l*r + c_c === 0`
 */
declare function generic(coefficients: {
    left: bigint;
    right: bigint;
    out: bigint;
    mul: bigint;
    const: bigint;
}, inputs: {
    left: Field;
    right: Field;
    out: Field;
}): void;
declare function zero(a: Field, b: Field, c: Field): void;
