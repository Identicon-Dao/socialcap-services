var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { SmartContract, state, State, method, Reducer, PublicKey } from "o1js";
import { Field, Struct, Circuit, Poseidon } from "o1js";
import { MerkleMapWitness } from "o1js";
import { MerkleMapProxy, MerkleMapUpdate } from "./CommunitiesContract.js";
export { VotesBatch, ElectorsInPlanNullifierProxy, VotingBatchesContract };
/** States of the Voting process */
const ACTIVE = 1, ENDED = 2, CANCELED = 3;
/**
 * This is an actual batch of votes sent by a given elector, on a given
 * voting process (the planUid represents this voting process).
 */
class VotesBatch extends Struct({
    communityUid: Field,
    planUid: Field,
    electorUid: Field,
    uid: Field,
    batchComittment: Field,
    size: Field,
    submitedUTC: Field
}) {
}
/**
 * This action will be dispatched by the receiveVotesBatch @method
 * when a new batch of votes is received. We use "actions" here because
 * we want this to be settled in MINA archive nodes.
 */
class VotesBatchReceivedAction extends VotesBatch {
}
/**
 * This event will be dispatched by the receiveVotesBatch @method
 * when a new batch of votes is received. It is assumed it will
 * be consumed by some off chain process.
 */
class VotesBatchReceivedEvent extends VotesBatch {
}
/** Voting states for an Elector on this voting Plan */
const UNASSIGNED = Field(0), // not assigned to this elector
ASSIGNED = Field(1), // assigned to elector but has not voted yet
VOTED = Field(2); // assigned to elector and has already voted
class ElectorsInPlanNullifierProxy extends Struct({
    root: Field,
    witness: MerkleMapWitness
}) {
    static key(electorId, planUid) {
        Circuit.log(electorId, planUid);
        const keyd = Poseidon.hash(electorId.toFields()
            .concat(planUid.toFields()));
        Circuit.log("Key (", electorId, planUid, ") =>", keyd);
        return keyd;
    }
}
/**
 * This is the voting contract binded to a given credential voting process, which
 * is represented by its master plan.
 *
 * It manages all votes batches received from electors, emit actions on each
 * batch, and finally commit all received batches.
 *
 * This contract mainly asserts that the electors voted and dispatched their
 * batches. We can not know if some electors did not dispatch them, this may
 * be validated in other parts (such as the UI or the API)
 */
class VotingBatchesContract extends SmartContract {
    constructor() {
        super(...arguments);
        // events to update VotingBatchesMerkleTree
        this.events = {
            'votes_batch_received': VotesBatchReceivedEvent
        };
        // the "reducer" field describes a type of action that we can dispatch, and reduce later
        this.reducer = Reducer({ actionType: VotesBatchReceivedAction });
        // associated MasterPlan. This is the voting process Uid 
        // and is binded to a given Credentials voting process.
        this.planUid = State();
        // associated Community where voting took place
        this.communityUid = State();
        // current Voting Batches MerkleTree commitment
        this.batchesCommitment = State();
        // final state of the voting process // 2: FINISHED, 1: ACTIVE
        this.votingState = State();
        // helper field to store the actual point in the actions history
        this.actionsState = State();
    }
    init() {
        super.init();
        this.planUid.set(Field(0));
        this.communityUid.set(Field(0));
        this.batchesCommitment.set(Field(0));
        this.votingState.set(Field(ACTIVE)); // it starts as an active voting
        this.actionsState.set(Reducer.initialActionState); // TODO: is this the right way to initialize this ???
    }
    assertIsValidElector(
    /**
     * Checks if the given elector has been assigned to this voting process
     */
    electorPuk, planUid, nullifier) {
        // compute a root and key from the given Witness using the only valid 
        // value ASSIGNED, other values indicate that the elector was 
        // never assigned to this claim or that he has already voted on it
        const [witnessRoot, witnessKey] = nullifier.witness.computeRootAndKey(ASSIGNED /* WAS ASSIGNED */);
        Circuit.log("assertIsValidElector witnessRoot", witnessRoot);
        Circuit.log("assertIsValidElector witnessKey", witnessKey);
        // check the witness obtained root matchs the Nullifier root
        nullifier.root.assertEquals(witnessRoot, "Invalid elector root");
        // check the witness obtained key matchs the elector+claim key 
        const key = ElectorsInPlanNullifierProxy.key(electorPuk, planUid);
        Circuit.log("assertIsValidElector recalculated Key", key);
        witnessKey.assertEquals(key, "Invalid elector key");
    }
    receiveVotesBatch(votesBatch, nullifier) {
        /**
         * Receives a VotesBatch, asserts it, and emits an Action and en Event
         */
        const planUid = this.planUid.getAndAssertEquals();
        const communityUid = this.communityUid.getAndAssertEquals();
        const votingState = this.votingState.getAndAssertEquals();
        // assert the batch corresponds to this community and plan
        communityUid.assertEquals(votesBatch.communityUid);
        planUid.assertEquals(votesBatch.planUid);
        // the elector Pub key is the one sending the Tx
        let electorPuk = this.sender;
        electorPuk.assertEquals(this.sender);
        // check this elector is part of the Electors set 
        Circuit.log("sendVote key=", ElectorsInPlanNullifierProxy.key(electorPuk, planUid));
        this.assertIsValidElector(electorPuk, planUid, nullifier);
        // check that we have not already finished 
        // and that we can receive additional batches
        votingState.assertEquals(ACTIVE);
        // dispatch action
        const action = votesBatch;
        this.reducer.dispatch(action);
        Circuit.log("dispatched action", action);
        // send event to change this elector state in Nullifier
        this.emitEvent("votes_batch_received", votesBatch);
    }
    rollupAllBatches(map, witness, updated) {
        const planUid = this.planUid.getAndAssertEquals();
        const communityUid = this.communityUid.getAndAssertEquals();
        const votingState = this.votingState.getAndAssertEquals();
        // check that this claim is still open (in the voting process)
        votingState.assertEquals(ACTIVE, "Voting has already finished !");
        // get the point in history where we left the last rollup
        let actionsState = this.actionsState.get();
        this.actionsState.assertEquals(actionsState);
        Circuit.log("rollupBatches actionsState=", actionsState);
        // get all votes not counted since last rollup
        let pendingBatches = this.reducer.getActions({
            fromActionState: actionsState,
        });
        Circuit.log("rollupBatches pendingBatches.length=", pendingBatches.length);
        //     // build Voting initial state for Reducer
        //     let votingState: Votes = {
        //       total: votes,
        //       positive: positives,
        //       negative: negatives,
        //       ignored: ignored,
        //     };
        // 
        //     let { 
        //       state: newVotes, 
        //       actionState: newActionsState 
        //     } = this.reducer.reduce(
        //       pendingVotes, // pending votes to reduce
        //       Votes,        // the state type
        //       function (    // function that says how to apply the action
        //         state: Votes, 
        //         action: VoteAction
        //       ) {
        //         // we can use a reducer here because it is not important if votes arrive 
        //         // in different order than the one they were emited. we just need more
        //         // than the total required votes to be done
        //         Circuit.log("---");
        //         Circuit.log("reducer action=", action);
        //         Circuit.log("reducer before state=", state);
        //         const notFinished = state.total.lessThan(requiredVotes);
        //         const mustCount = notFinished.and(action.isValid);
        //         Circuit.log("reducer notFinished=", notFinished, "isValid=", action.isValid, " mustCount=", mustCount);
        //         state.total = Circuit.if(mustCount, state.total.add(1), state.total);
        //         state.positive = Circuit.if(mustCount.and(action.positive), state.positive.add(1), state.positive);
        //         state.negative = Circuit.if(mustCount.and(action.negative), state.negative.add(1), state.negative);
        //         state.ignored = Circuit.if(mustCount.and(action.ignore), state.ignored.add(1), state.ignored);
        //         Circuit.log("reducer after state=", state);
        //         return state;
        //       },
        //       { state: votingState, actionState: actionsState } // initial state and actions point
        //     );
        //     Circuit.log("reducer final state=", newVotes);
        // 
        //     // update on-chain voting and actions state
        //     this.actionsState.set(newActionsState);
        //     this.positive.set(newVotes.positive);
        //     this.negative.set(newVotes.negative);
        //     this.ignored.set(newVotes.ignored);
        // 
        //     // check if we have met end voting conditions
        //     let isFinished = newVotes.total.greaterThanOrEqual(requiredVotes);
        //     let isApproved = newVotes.positive.greaterThanOrEqual(requiredPositives);
        //          
        //     // assert result before changing its value
        //     let result = this.result.get();
        //     this.result.assertEquals(result);
        // 
        //     // now evaluate final result
        //     let newResult = Circuit.if(isFinished, 
        //       Circuit.if(isApproved, APPROVED, REJECTED),
        //       result
        //     );
        // 
        //     // update final on-chain result state
        //     this.result.set(newResult);
        // 
        //     // check if it has changed so we can report it with the event
        //     let resultHasChanged = newResult.greaterThan(result);
        // 
        //     // and send event with actual result, even if it is not yet finished
        //     // TODO: can we use an if condition here? I think it cant be done
        //     this.emitEvent("voting-changed", {
        //       claimUid: claimUid,
        //       isFinished: isFinished,
        //       hasChanged: resultHasChanged,
        //       result: result,
        //       total: newVotes.total,
        //       positive: newVotes.positive,
        //       negative: newVotes.negative,
        //       ignored: newVotes.ignored
        //     });
        // 
        //     Circuit.log("rollupClaims result=", newResult);
        //     Circuit.log("rollupClaims isFinished=", isFinished);
        //     Circuit.log("rollupClaims isApproved=", isApproved);
    }
}
__decorate([
    state(Field),
    __metadata("design:type", Object)
], VotingBatchesContract.prototype, "planUid", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], VotingBatchesContract.prototype, "communityUid", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], VotingBatchesContract.prototype, "batchesCommitment", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], VotingBatchesContract.prototype, "votingState", void 0);
__decorate([
    state(Field),
    __metadata("design:type", Object)
], VotingBatchesContract.prototype, "actionsState", void 0);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [PublicKey,
        Field,
        ElectorsInPlanNullifierProxy]),
    __metadata("design:returntype", void 0)
], VotingBatchesContract.prototype, "assertIsValidElector", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [VotesBatch,
        ElectorsInPlanNullifierProxy]),
    __metadata("design:returntype", void 0)
], VotingBatchesContract.prototype, "receiveVotesBatch", null);
__decorate([
    method,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MerkleMapProxy,
        MerkleMapWitness,
        MerkleMapUpdate]),
    __metadata("design:returntype", void 0)
], VotingBatchesContract.prototype, "rollupAllBatches", null);
//# sourceMappingURL=PlanVotingContract.js.map