import { SmartContract, State, PublicKey } from "o1js";
import { Field } from "o1js";
import { MerkleMapWitness } from "o1js";
import { MerkleMapProxy, MerkleMapUpdate } from "./CommunitiesContract.js";
export { VotesBatch, ElectorsInPlanNullifierProxy, VotingBatchesContract };
declare const VotesBatch_base: (new (value: {
    communityUid: import("o1js/dist/node/lib/field.js").Field;
    planUid: import("o1js/dist/node/lib/field.js").Field;
    electorUid: import("o1js/dist/node/lib/field.js").Field;
    uid: import("o1js/dist/node/lib/field.js").Field;
    batchComittment: import("o1js/dist/node/lib/field.js").Field;
    size: import("o1js/dist/node/lib/field.js").Field;
    submitedUTC: import("o1js/dist/node/lib/field.js").Field;
}) => {
    communityUid: import("o1js/dist/node/lib/field.js").Field;
    planUid: import("o1js/dist/node/lib/field.js").Field;
    electorUid: import("o1js/dist/node/lib/field.js").Field;
    uid: import("o1js/dist/node/lib/field.js").Field;
    batchComittment: import("o1js/dist/node/lib/field.js").Field;
    size: import("o1js/dist/node/lib/field.js").Field;
    submitedUTC: import("o1js/dist/node/lib/field.js").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    communityUid: import("o1js/dist/node/lib/field.js").Field;
    planUid: import("o1js/dist/node/lib/field.js").Field;
    electorUid: import("o1js/dist/node/lib/field.js").Field;
    uid: import("o1js/dist/node/lib/field.js").Field;
    batchComittment: import("o1js/dist/node/lib/field.js").Field;
    size: import("o1js/dist/node/lib/field.js").Field;
    submitedUTC: import("o1js/dist/node/lib/field.js").Field;
}> & {
    toInput: (x: {
        communityUid: import("o1js/dist/node/lib/field.js").Field;
        planUid: import("o1js/dist/node/lib/field.js").Field;
        electorUid: import("o1js/dist/node/lib/field.js").Field;
        uid: import("o1js/dist/node/lib/field.js").Field;
        batchComittment: import("o1js/dist/node/lib/field.js").Field;
        size: import("o1js/dist/node/lib/field.js").Field;
        submitedUTC: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        communityUid: import("o1js/dist/node/lib/field.js").Field;
        planUid: import("o1js/dist/node/lib/field.js").Field;
        electorUid: import("o1js/dist/node/lib/field.js").Field;
        uid: import("o1js/dist/node/lib/field.js").Field;
        batchComittment: import("o1js/dist/node/lib/field.js").Field;
        size: import("o1js/dist/node/lib/field.js").Field;
        submitedUTC: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        communityUid: string;
        planUid: string;
        electorUid: string;
        uid: string;
        batchComittment: string;
        size: string;
        submitedUTC: string;
    };
    fromJSON: (x: {
        communityUid: string;
        planUid: string;
        electorUid: string;
        uid: string;
        batchComittment: string;
        size: string;
        submitedUTC: string;
    }) => {
        communityUid: import("o1js/dist/node/lib/field.js").Field;
        planUid: import("o1js/dist/node/lib/field.js").Field;
        electorUid: import("o1js/dist/node/lib/field.js").Field;
        uid: import("o1js/dist/node/lib/field.js").Field;
        batchComittment: import("o1js/dist/node/lib/field.js").Field;
        size: import("o1js/dist/node/lib/field.js").Field;
        submitedUTC: import("o1js/dist/node/lib/field.js").Field;
    };
};
/**
 * This is an actual batch of votes sent by a given elector, on a given
 * voting process (the planUid represents this voting process).
 */
declare class VotesBatch extends VotesBatch_base {
}
/**
 * This action will be dispatched by the receiveVotesBatch @method
 * when a new batch of votes is received. We use "actions" here because
 * we want this to be settled in MINA archive nodes.
 */
declare class VotesBatchReceivedAction extends VotesBatch {
}
/**
 * This event will be dispatched by the receiveVotesBatch @method
 * when a new batch of votes is received. It is assumed it will
 * be consumed by some off chain process.
 */
declare class VotesBatchReceivedEvent extends VotesBatch {
}
declare const ElectorsInPlanNullifierProxy_base: (new (value: {
    root: import("o1js/dist/node/lib/field.js").Field;
    witness: MerkleMapWitness;
}) => {
    root: import("o1js/dist/node/lib/field.js").Field;
    witness: MerkleMapWitness;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    root: import("o1js/dist/node/lib/field.js").Field;
    witness: MerkleMapWitness;
}> & {
    toInput: (x: {
        root: import("o1js/dist/node/lib/field.js").Field;
        witness: MerkleMapWitness;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        root: import("o1js/dist/node/lib/field.js").Field;
        witness: MerkleMapWitness;
    }) => {
        root: string;
        witness: any;
    };
    fromJSON: (x: {
        root: string;
        witness: any;
    }) => {
        root: import("o1js/dist/node/lib/field.js").Field;
        witness: MerkleMapWitness;
    };
};
declare class ElectorsInPlanNullifierProxy extends ElectorsInPlanNullifierProxy_base {
    static key(electorId: PublicKey, planUid: Field): Field;
}
/**
 * This is the voting contract binded to a given credential voting process, which
 * is represented by its master plan.
 *
 * It manages all votes batches received from electors, emit actions on each
 * batch, and finally commit all received batches.
 *
 * This contract mainly asserts that the electors voted and dispatched their
 * batches. We can not know if some electors did not dispatch them, this may
 * be validated in other parts (such as the UI or the API)
 */
declare class VotingBatchesContract extends SmartContract {
    events: {
        votes_batch_received: typeof VotesBatchReceivedEvent;
    };
    reducer: {
        dispatch(action: VotesBatchReceivedAction): void;
        reduce<State_1>(actions: VotesBatchReceivedAction[][], stateType: import("o1js/dist/node/lib/provable.js").Provable<State_1>, reduce: (state: State_1, action: VotesBatchReceivedAction) => State_1, initial: {
            state: State_1;
            actionState: import("o1js/dist/node/lib/field.js").Field;
        }, options?: {
            maxTransactionsWithActions?: number | undefined;
            skipActionStatePrecondition?: boolean | undefined;
        } | undefined): {
            state: State_1;
            actionState: import("o1js/dist/node/lib/field.js").Field;
        };
        forEach(actions: VotesBatchReceivedAction[][], reduce: (action: VotesBatchReceivedAction) => void, fromActionState: import("o1js/dist/node/lib/field.js").Field, options?: {
            maxTransactionsWithActions?: number | undefined;
            skipActionStatePrecondition?: boolean | undefined;
        } | undefined): import("o1js/dist/node/lib/field.js").Field;
        getActions({ fromActionState, endActionState, }?: {
            fromActionState?: import("o1js/dist/node/lib/field.js").Field | undefined;
            endActionState?: import("o1js/dist/node/lib/field.js").Field | undefined;
        } | undefined): VotesBatchReceivedAction[][];
        fetchActions({ fromActionState, endActionState, }: {
            fromActionState?: import("o1js/dist/node/lib/field.js").Field | undefined;
            endActionState?: import("o1js/dist/node/lib/field.js").Field | undefined;
        }): Promise<VotesBatchReceivedAction[][]>;
    };
    planUid: State<import("o1js/dist/node/lib/field.js").Field>;
    communityUid: State<import("o1js/dist/node/lib/field.js").Field>;
    batchesCommitment: State<import("o1js/dist/node/lib/field.js").Field>;
    votingState: State<import("o1js/dist/node/lib/field.js").Field>;
    actionsState: State<import("o1js/dist/node/lib/field.js").Field>;
    init(): void;
    assertIsValidElector(
    /**
     * Checks if the given elector has been assigned to this voting process
     */
    electorPuk: PublicKey, planUid: Field, nullifier: ElectorsInPlanNullifierProxy): void;
    receiveVotesBatch(votesBatch: VotesBatch, nullifier: ElectorsInPlanNullifierProxy): void;
    rollupAllBatches(map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
}
