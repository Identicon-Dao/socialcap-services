import { SmartContract, State } from "o1js";
import { Field, MerkleMapWitness } from "o1js";
import { MerkleMapProxy, MerkleMapUpdate } from "./CommunitiesContract.js";
import { ProvableClaim } from "./models/provable-claims.js";
import { ProvablePlan } from "./models/provable-plans.js";
import { ProvableCredential } from "./models/provable-credentials.js";
export declare class ClaimingsContract extends SmartContract {
    plansRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    claimsRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    credentialsRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    init(): void;
    zeroRoot(): Field;
    /**
     * Check that only the contract deployer can call the method.
     * The deployer will be the Socialcap main account, which will also act
     * as fee payer for most method calls that imply commited roots bookeeping.
     * WARNING: If the Socialcap account changes we need to redeploy the contract.
     */
    assertOnlyDeployer(): void;
    /**
     * Checks that the given update (key and leaf data after and before)
     * efectively belong to the commited Merkle Map.
     */
    checkMerkleUpdate(key: Field, hashed: Field, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate, currentRoot: Field): void;
    updateClaim(claim: ProvableClaim, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
    updatePlan(plan: ProvablePlan, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
    updateCredential(credential: ProvableCredential, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
}
