import { SmartContract, State } from "o1js";
import { Field, UInt32, MerkleMapWitness } from "o1js";
import { ProvableCommunity } from "./models/provable-community.js";
import { ProvablePerson } from "./models/provable-person.js";
import { ProvableMember } from "./models/provable-member.js";
declare const LeafInstance_base: (new (value: {
    key: import("o1js/dist/node/lib/field.js").Field;
    hash: import("o1js/dist/node/lib/field.js").Field;
}) => {
    key: import("o1js/dist/node/lib/field.js").Field;
    hash: import("o1js/dist/node/lib/field.js").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    key: import("o1js/dist/node/lib/field.js").Field;
    hash: import("o1js/dist/node/lib/field.js").Field;
}> & {
    toInput: (x: {
        key: import("o1js/dist/node/lib/field.js").Field;
        hash: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        key: import("o1js/dist/node/lib/field.js").Field;
        hash: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        key: string;
        hash: string;
    };
    fromJSON: (x: {
        key: string;
        hash: string;
    }) => {
        key: import("o1js/dist/node/lib/field.js").Field;
        hash: import("o1js/dist/node/lib/field.js").Field;
    };
};
/**
 * LeafInstance
 * Describes a MerkleMap leaf, which contains both the 'data' stored in the
 * leaf and the 'hash' of this data. The 'hash' value is calculated by
 * the 'set(key,data)' method when we update the MerkleMap.
 */
export declare class LeafInstance extends LeafInstance_base {
}
declare const MerkleMapUpdate_base: (new (value: {
    txId: import("o1js/dist/node/lib/field.js").Field;
    mapId: UInt32;
    beforeRoot: import("o1js/dist/node/lib/field.js").Field;
    beforeLeaf: LeafInstance;
    afterRoot: import("o1js/dist/node/lib/field.js").Field;
    afterLeaf: LeafInstance;
}) => {
    txId: import("o1js/dist/node/lib/field.js").Field;
    mapId: UInt32;
    beforeRoot: import("o1js/dist/node/lib/field.js").Field;
    beforeLeaf: LeafInstance;
    afterRoot: import("o1js/dist/node/lib/field.js").Field;
    afterLeaf: LeafInstance;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    txId: import("o1js/dist/node/lib/field.js").Field;
    mapId: UInt32;
    beforeRoot: import("o1js/dist/node/lib/field.js").Field;
    beforeLeaf: LeafInstance;
    afterRoot: import("o1js/dist/node/lib/field.js").Field;
    afterLeaf: LeafInstance;
}> & {
    toInput: (x: {
        txId: import("o1js/dist/node/lib/field.js").Field;
        mapId: UInt32;
        beforeRoot: import("o1js/dist/node/lib/field.js").Field;
        beforeLeaf: LeafInstance;
        afterRoot: import("o1js/dist/node/lib/field.js").Field;
        afterLeaf: LeafInstance;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        txId: import("o1js/dist/node/lib/field.js").Field;
        mapId: UInt32;
        beforeRoot: import("o1js/dist/node/lib/field.js").Field;
        beforeLeaf: LeafInstance;
        afterRoot: import("o1js/dist/node/lib/field.js").Field;
        afterLeaf: LeafInstance;
    }) => {
        txId: string;
        mapId: string;
        beforeRoot: string;
        beforeLeaf: {
            key: string;
            hash: string;
        };
        afterRoot: string;
        afterLeaf: {
            key: string;
            hash: string;
        };
    };
    fromJSON: (x: {
        txId: string;
        mapId: string;
        beforeRoot: string;
        beforeLeaf: {
            key: string;
            hash: string;
        };
        afterRoot: string;
        afterLeaf: {
            key: string;
            hash: string;
        };
    }) => {
        txId: import("o1js/dist/node/lib/field.js").Field;
        mapId: UInt32;
        beforeRoot: import("o1js/dist/node/lib/field.js").Field;
        beforeLeaf: LeafInstance;
        afterRoot: import("o1js/dist/node/lib/field.js").Field;
        afterLeaf: LeafInstance;
    };
};
/**
 * MerkleMapUpdate
 * Describes the last "provable?" change applied to a given OffchainMerkleMap
 * after using the .set(key,data) method on it. It can be used to update the
 * state of commitment (a Merkle root) in a MINA account.
 * Contains both the previous map state and the current updated state.
*/
export declare class MerkleMapUpdate extends MerkleMapUpdate_base {
}
declare const MerkleMapProxy_base: (new (value: {
    id: UInt32;
    name: any;
    root: import("o1js/dist/node/lib/field.js").Field;
    count: import("o1js/dist/node/lib/field.js").Field;
}) => {
    id: UInt32;
    name: any;
    root: import("o1js/dist/node/lib/field.js").Field;
    count: import("o1js/dist/node/lib/field.js").Field;
}) & {
    _isStruct: true;
} & import("o1js/dist/node/snarky.js").ProvablePure<{
    id: UInt32;
    name: any;
    root: import("o1js/dist/node/lib/field.js").Field;
    count: import("o1js/dist/node/lib/field.js").Field;
}> & {
    toInput: (x: {
        id: UInt32;
        name: any;
        root: import("o1js/dist/node/lib/field.js").Field;
        count: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        fields?: import("o1js/dist/node/lib/field.js").Field[] | undefined;
        packed?: [import("o1js/dist/node/lib/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        id: UInt32;
        name: any;
        root: import("o1js/dist/node/lib/field.js").Field;
        count: import("o1js/dist/node/lib/field.js").Field;
    }) => {
        id: string;
        name: any;
        root: string;
        count: string;
    };
    fromJSON: (x: {
        id: string;
        name: any;
        root: string;
        count: string;
    }) => {
        id: UInt32;
        name: any;
        root: import("o1js/dist/node/lib/field.js").Field;
        count: import("o1js/dist/node/lib/field.js").Field;
    };
};
/**
 * Represents a MerkleMap existing in the offchain storage.
 * We dont have the map data (nodes or leafs) here, we just
 * have the root and some identification info.
 */
export declare class MerkleMapProxy extends MerkleMapProxy_base {
}
export declare class CommunitiesContract extends SmartContract {
    communitiesRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    personsRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    membersRoot: State<import("o1js/dist/node/lib/field.js").Field>;
    init(): void;
    zeroRoot(): Field;
    /**
     * Check that only the contract deployer can call the method.
     * The deployer will be the Socialcap main account, which will also act
     * as fee payer for most method calls that imply commited roots bookeeping.
     * WARNING: If the Socialcap account changes we need to redeploy the contract.
     */
    assertOnlyDeployer(): void;
    /**
     * Checks that the given update (key and leaf data after and before)
     * efectively belong to the commited Merkle Map.
     */
    checkMerkleUpdate(key: Field, hashed: Field, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate, currentRoot: Field): void;
    updateCommunity(org: ProvableCommunity, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
    updatePerson(person: ProvablePerson, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
    updateMember(member: ProvableMember, map: MerkleMapProxy, witness: MerkleMapWitness, updated: MerkleMapUpdate): void;
}
export {};
